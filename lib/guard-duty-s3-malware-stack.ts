import * as cdk from 'aws-cdk-lib';
import { Bastion } from './bastion';
import { Construct } from 'constructs';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as gd from 'aws-cdk-lib/aws-guardduty';

export class GuardDutyS3MalwareStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const vpc = new ec2.Vpc(this, 'Vpc', {
      maxAzs: 1,
      ipAddresses: ec2.IpAddresses.cidr('10.0.0.0/24')
    });    

    const bkt = new s3.Bucket(this, 'Bucket', {
      enforceSSL: true,
      minimumTLSVersion: 1.2,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      encryption: s3.BucketEncryption.S3_MANAGED,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL
    });

    // to-do: lower permissions
    const pol = 'AdministratorAccess'
    const svc = 'malware-protection-plan.guardduty.amazonaws.com';
    const role = new iam.Role(this, 'MyRole', {
      assumedBy: new iam.ServicePrincipal(svc),
      managedPolicies: [iam.ManagedPolicy.fromAwsManagedPolicyName(pol)]
    });    

    new gd.CfnMalwareProtectionPlan(this, 'Plan', {
      role: role.roleArn,
      protectedResource: {
        s3Bucket: {
          bucketName: bkt.bucketName
        }
      },
      actions: {
        tagging: {
          status: 'ENABLED'
        }
      }
    });

    // unable to download test file with cloudshell or workspace, use ec2 instead
    const host = new Bastion(this, 'Bastion', { vpc, bucketName: bkt.bucketName }).host;
    bkt.grantReadWrite(host);
  }
}
